name: GetManager
permissions:
  contents: write  # Allow writing to repository contents (for pushing tags)
  actions: read   # Allows triggering actions

on:
  workflow_call: # This allows this workflow to be called from another workflow
    inputs:
      kernelsu_variant:
        required: true
        type: string
      kernelsu_commit:
        required: false
        type: string
    outputs:
      susVer:
        description: "The fetched SUSFS version number"
        value: ${{ jobs.get_ksu_manager.outputs.susVer }}
      ksuVer:
        description: "The calculated KSU version number"
        value: ${{ jobs.get_ksu_manager.outputs.ksuVer }}

jobs:
  get_ksu_manager:
    runs-on: ubuntu-latest
    outputs:
      # Output 1: KSU version number
      ksuVer: ${{ steps.get_version.outputs.kversion }}
      # Output 2: SUSFS version number
      susVer: ${{ steps.get_version.outputs.sversion }}
    env:
      CCACHE_COMPILERCHECK: "%compiler% -dumpmachine; %compiler% -dumpversion"
      CCACHE_NOHASHDIR: "true"
      CCACHE_HARDLINK: "true"
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    steps:
      - name: ðŸ§ Debug Workflow Caller Context
        run: |
          echo "==================== DEBUG CONTEXT ===================="
          echo " "
          echo "EVENT NAME: ${{ github.event_name }}"
          echo " "
          echo "--- CALLER INFORMATION ---"
          echo "  - Caller Repository: ${{ github.caller_repository }}"
          echo "  - Caller Workflow:   ${{ github.caller_workflow }}"
          echo "  - Caller User:       ${{ github.triggering_actor }}"
          echo " "
          echo "--- WORKFLOW & JOB INFORMATION ---"
          echo "  - Current Workflow:  ${{ github.workflow }}"
          echo "  - Current Job ID:    ${{ github.job }}"
          echo "  - Current Run ID:    ${{ github.run_id }}"
          echo "  - Current Run Number:${{ github.run_number }}"
          echo " "
          echo "--- GIT REFERENCE INFORMATION ---"
          echo "  - Git Ref:           ${{ github.ref }}"
          echo "  - Ref Type:          ${{ github.ref_type }}"
          echo " "
          echo "======================================================="
          
      - name: Install dependencies
        run: sudo apt install -y git curl jq

      - name: Get KSU & SUSFS versions
        id: get_version
        run: |
          set -euo pipefail
          KERNELSU_VARIANT="${{ inputs.kernelsu_variant }}"
          KERNELSU_COMMIT="${{ inputs.kernelsu_commit }}"   # may be empty
          echo "Resolving KSU repo for variant: $KERNELSU_VARIANT (commit: ${KERNELSU_COMMIT:-none})"
          if [ "$KERNELSU_VARIANT" = "Next" ]; then
            echo "This is the Next variant"
            git clone https://github.com/KernelSU-Next/KernelSU-Next.git Verfold
          elif [ "$KERNELSU_VARIANT" = "SukiSU" ]; then
            echo "This is the SukiSU variant"
            git clone https://github.com/SukiSU-Ultra/SukiSU-Ultra.git Verfold
          elif [ "$KERNELSU_VARIANT" = "Official" ]; then
            echo "This is the Official variant"
            git clone https://github.com/tiann/KernelSU.git Verfold
          elif [ "$KERNELSU_VARIANT" = "MKSU" ]; then
            echo "This is the MKSU variant"
            git clone https://github.com/5ec1cff/KernelSU.git Verfold
          else
            echo "Unknown variant: $KERNELSU_VARIANT"
            exit 1
          fi
          cd Verfold
          if [ -n "$KERNELSU_COMMIT" ]; then
          echo "User requested KernelSU commit: $KERNELSU_COMMIT â€” fetching and checking out"
          # Try to fetch the commit quickly (shallow), but if that makes history incomplete, unshallow.
          # 1) Try shallow fetch of the specific commit (fast)
          git fetch --depth=1 origin "$KERNELSU_COMMIT" || true
          # 2) If the repository is shallow or the commit has no ancestors locally, try to unshallow to get full history
          #    (this makes git rev-list --count return the repo-wide count).
          if git rev-parse --is-shallow-repository >/dev/null 2>&1 && [ "$(git rev-parse --is-shallow-repository 2>/dev/null)" = "true" ]; then
            echo "Repository is shallow â€” attempting to unshallow to get full history..."
            git fetch --unshallow origin || {
              echo "unshallow failed, attempting deep fetch of all refs..."
              git fetch --depth=50000 origin || true
            }
          fi
          # Ensure the commit is present, try fetching it fully if needed
          git fetch origin "$KERNELSU_COMMIT" || git fetch --depth=1 origin "$KERNELSU_COMMIT" || true
          # Finally checkout the exact commit detached
          git checkout --detach "$KERNELSU_COMMIT"
          else
          echo "No specific commit requested â€” using repo HEAD"
          fi
          # Calculating the KSU version number based on commit count
          KSU_GIT_VERSION=$(git rev-list --count HEAD)
          VAR=$([[ "$KERNELSU_VARIANT" == "SukiSU" ]] && echo 700 || echo 200)
          KSU_VERSION=$((10000 + KSU_GIT_VERSION + VAR))
          if [ "$KERNELSU_VARIANT" = "SukiSU" ]; then
            KSU_VERSION=$((40000 + KSU_GIT_VERSION - 2815))
          elif [ "$KERNELSU_VARIANT" = "Official" ] || [ "$KERNELSU_VARIANT" = "MKSU" ]; then
            KSU_VERSION=$((30000 + KSU_GIT_VERSION))
          elif [ "$KERNELSU_VARIANT" = "Next" ]; then
            KSU_VERSION=$((30001 + KSU_GIT_VERSION))
          fi
          echo "Determined KSU numeric version: $KSU_VERSION (commit: $(git rev-parse --short HEAD))"
          echo $KSU_VERSION
          echo "KSU_VERSION=$KSU_VERSION" >> $GITHUB_ENV
          # cleanup
          echo "Deleting the directory"
          cd ..
          rm -rf Verfold

          # Calculating the SUSFS version number
          INFO="https://gitlab.com/simonpunk/susfs4ksu/-/raw/gki-android14-6.1/ksu_module_susfs/module.prop\?ref_type\=heads"
          SUS_VERSION=$(curl -s $INFO | awk -F '=' '$1 == "version" { print $2 }')
          echo $SUS_VERSION

          # Export these two values â€‹â€‹to release
          echo "kversion=$KSU_VERSION" >> $GITHUB_OUTPUT
          echo "sversion=$SUS_VERSION" >> $GITHUB_OUTPUT

      - name: Add KernelSU
        id: add_KSU
        continue-on-error: true
        run: |
          if [ "${{ inputs.kernelsu_variant }}" == "Next" ]; then
            echo "KernelSU Next..."
            REPO="KernelSU-Next/KernelSU-Next"
            KSUM="manager"
          elif [ "${{ inputs.kernelsu_variant }}" == "SukiSU" ]; then
            echo "SukiSU..."
            REPO="SukiSU-Ultra/SukiSU-Ultra"
            KSUM="Manager"
          elif [ "${{ inputs.kernelsu_variant }}" == "MKSU" ]; then
            echo "MKSU..."
            REPO="5ec1cff/KernelSU"
            KSUM="manager"
          elif [ "${{ inputs.kernelsu_variant }}" == "Official" ]; then
            echo "KSU..."
            REPO="tiann/KernelSU"
            KSUM="manager"
          fi
          FILENAME=$([[ "${{ inputs.kernelsu_variant }}" == "Next" ]] && echo "build-manager-ci.yml" || echo "build-manager.yml")          
          # Initialize
          NUMBER=0
          DOWNLOAD_URL=""
          echo "Start searching for builds containing the 'manager' artifact..."
          # Debug + variable setup
          echo "DEBUG: Entering Manager selection block"
          echo "DEBUG: inputs.kernelsu_variant = '${{ inputs.kernelsu_variant }}'"
          echo "DEBUG: inputs.kernelsu_commit  = '${{ inputs.kernelsu_commit }}'"
          echo "DEBUG: env.KSU_VERSION (if set) = '${{ env.KSU_VERSION }}'"
          REPO="${REPO:-$REPO}"             # owner/repo
          FILENAME="${FILENAME:-$FILENAME}" # workflow filename (e.g. build-manager.yml)
          KSUM="${KSUM:-$KSUM}"             # artifact matching string (e.g. manager)
          KERNELSU_COMMIT="${{ inputs.kernelsu_commit }}"
          KSU_VERSION_FROM_ENV="${{ env.KSU_VERSION }}"
          # normalized token for safe grep
          if [ -n "$KSU_VERSION_FROM_ENV" ]; then
            KSU_MATCH_TOKEN=$(echo "$KSU_VERSION_FROM_ENV" | sed 's/[^0-9A-Za-z._-]/./g')
          else
            KSU_MATCH_TOKEN=""
          fi
          PER_PAGE=50
          MAX_PAGES=6          # adjust if you need to search deeper
          FOUND_DOWNLOAD_URL=""
          FOUND_BUILD_ID=""
          FOUND_RUN_HEAD_SHA=""
          MATCH_BY_KSUVER=false
          if [ -z "$KERNELSU_COMMIT" ] && [ -n "$KSU_MATCH_TOKEN" ]; then
            MATCH_BY_KSUVER=true
            echo "DEBUG: No commit input; will try KSUVER content/filename matching: $KSU_MATCH_TOKEN"
          fi
          echo "Searching for Manager artifact (name contains '$KSUM') in workflow $FILENAME of repo $REPO"
          echo "Requested commit: ${KERNELSU_COMMIT:-<none>}"
          fetch_runs_page() {
            page=$1
            curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/$REPO/actions/workflows/$FILENAME/runs?status=success&per_page=$PER_PAGE&page=$page"
          }
          # 1) If commit provided: search for run with head_sha == commit and artifact present; verify zip filenames/contents optionally
          if [ -n "$KERNELSU_COMMIT" ]; then
            echo "Looking for runs whose head_sha matches requested commit..."
            for page in $(seq 1 $MAX_PAGES); do
              echo "Querying runs page $page..."
              runs_json=$(fetch_runs_page "$page")
              total=$(echo "$runs_json" | jq '.workflow_runs | length')
              if [ "$total" -eq 0 ]; then
                echo "No successful runs on page $page; stop."
                break
              fi
              for idx in $(seq 0 $((total-1))); do
                run=$(echo "$runs_json" | jq -c ".workflow_runs[$idx]")
                run_id=$(echo "$run" | jq -r '.id')
                head_sha=$(echo "$run" | jq -r '.head_sha')
                echo "  Inspect run id=$run_id head_sha=$head_sha"
                if [ "$head_sha" != "$KERNELSU_COMMIT" ]; then
                  continue
                fi
                echo "  -> head_sha matches requested commit. Checking artifacts for run $run_id..."
                artifacts=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  "https://api.github.com/repos/$REPO/actions/runs/$run_id/artifacts")
                art_name=$(echo "$artifacts" | jq -r '.artifacts[]?.name' | grep -E "$KSUM" | head -n1 || true)
                if [ -z "$art_name" ]; then
                  echo "    -> Run $run_id matches commit but no artifact matching '$KSUM'"
                  continue
                fi
                echo "    -> Candidate artifact '$art_name' found in run $run_id"
                download_url=$(echo "$artifacts" | jq -r --arg name "$art_name" '.artifacts[] | select(.name == $name) | .archive_download_url')
                tmpzip="$(mktemp -u /tmp/ksu_mgr.XXXXXX).zip"
                echo "    -> Downloading artifact for inspection..."
                curl -sL -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" -o "$tmpzip" "$download_url" || { echo "    -> download failed"; rm -f "$tmpzip"; continue; }
                FOUND_IN_ZIP=false
                if [ -n "$KSU_MATCH_TOKEN" ]; then
                  # 1) Check filenames inside the zip
                  if unzip -l "$tmpzip" >/tmp/zip_list.txt 2>/dev/null; then
                    if grep -q "$KSU_MATCH_TOKEN" /tmp/zip_list.txt; then
                      echo "    -> Token '$KSU_MATCH_TOKEN' found in ZIP filenames"
                      FOUND_IN_ZIP=true
                    else
                      echo "    -> Token '$KSU_MATCH_TOKEN' NOT found in ZIP filenames"
                    fi
                  else
                    echo "    -> unzip -l failed to list ZIP"
                  fi
                  # 2) If not found in filenames, check file contents
                  if [ "$FOUND_IN_ZIP" = false ]; then
                    if unzip -p "$tmpzip" 2>/dev/null | strings | grep -q "$KSU_MATCH_TOKEN"; then
                      echo "    -> Token '$KSU_MATCH_TOKEN' found in ZIP file contents"
                      FOUND_IN_ZIP=true
                    else
                      echo "    -> Token '$KSU_MATCH_TOKEN' NOT found in ZIP contents"
                    fi
                  fi
                else
                  echo "    -> No KSU_MATCH_TOKEN available; will accept artifact based on commit match"
                  FOUND_IN_ZIP=true
                fi
                rm -f /tmp/zip_list.txt
                rm -f "$tmpzip"
                if [ "$FOUND_IN_ZIP" = true ]; then
                  echo "    -> Accepting this artifact (matched commit and/or KSU token)"
                  FOUND_DOWNLOAD_URL="$download_url"
                  FOUND_BUILD_ID="$run_id"
                  FOUND_RUN_HEAD_SHA="$head_sha"
                  break 2
                else
                  echo "    -> Rejecting this artifact (no match in filenames or contents)"
                fi
              done
            done
            if [ -z "$FOUND_DOWNLOAD_URL" ]; then
              echo "No artifact found in runs matching the requested commit."
            fi
          fi
          # 2) If not found or commit not provided: fallback â€” search recent runs for artifact; prefer KSUVER-match when requested
          if [ -z "$FOUND_DOWNLOAD_URL" ]; then
            echo "Fallback search for artifact by presence (will prefer matches containing KSUVER if available)..."
            for page in $(seq 1 $MAX_PAGES); do
              echo "Scanning runs page $page..."
              runs_json=$(fetch_runs_page "$page")
              total=$(echo "$runs_json" | jq '.workflow_runs | length')
              if [ "$total" -eq 0 ]; then
                break
              fi
              for idx in $(seq 0 $((total-1))); do
                run=$(echo "$runs_json" | jq -c ".workflow_runs[$idx]")
                run_id=$(echo "$run" | jq -r '.id')
                head_sha=$(echo "$run" | jq -r '.head_sha')
                echo "  Fallback inspect run id=$run_id head_sha=$head_sha"
                artifacts=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  "https://api.github.com/repos/$REPO/actions/runs/$run_id/artifacts")
                art_name=$(echo "$artifacts" | jq -r '.artifacts[]?.name' | grep -E "$KSUM" | head -n1 || true)
                if [ -z "$art_name" ]; then
                  continue
                fi
                download_url=$(echo "$artifacts" | jq -r --arg name "$art_name" '.artifacts[] | select(.name == $name) | .archive_download_url')
                echo "    -> Found artifact '$art_name' in run $run_id"
                if [ "$MATCH_BY_KSUVER" = true ]; then
                  tmpzip="$(mktemp -u /tmp/ksu_mgr.XXXXXX).zip"
                  curl -sL -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" -o "$tmpzip" "$download_url" || { rm -f "$tmpzip"; continue; }
                  FOUND_IN_ZIP=false
                  if unzip -l "$tmpzip" >/tmp/zip_list.txt 2>/dev/null; then
                    if grep -q "$KSU_MATCH_TOKEN" /tmp/zip_list.txt; then
                      echo "    -> Token '$KSU_MATCH_TOKEN' found in ZIP filenames (fallback)"
                      FOUND_IN_ZIP=true
                    else
                      echo "    -> Token '$KSU_MATCH_TOKEN' NOT found in ZIP filenames (fallback)"
                    fi
                  fi
                  if [ "$FOUND_IN_ZIP" = false ]; then
                    if unzip -p "$tmpzip" 2>/dev/null | strings | grep -q "$KSU_MATCH_TOKEN"; then
                      echo "    -> Token '$KSU_MATCH_TOKEN' found in ZIP contents (fallback)"
                      FOUND_IN_ZIP=true
                    else
                      echo "    -> Token '$KSU_MATCH_TOKEN' NOT found in ZIP contents (fallback)"
                    fi
                  fi
                  rm -f /tmp/zip_list.txt
                  rm -f "$tmpzip"
                  if [ "$FOUND_IN_ZIP" = true ]; then
                    FOUND_DOWNLOAD_URL="$download_url"
                    FOUND_BUILD_ID="$run_id"
                    FOUND_RUN_HEAD_SHA="$head_sha"
                    break 3
                  else
                    echo "    -> Candidate does not contain KSU token; skipping (fallback)"
                    continue
                  fi
                else
                  FOUND_DOWNLOAD_URL="$download_url"
                  FOUND_BUILD_ID="$run_id"
                  FOUND_RUN_HEAD_SHA="$head_sha"
                  break 3
                fi
              done
            done
          fi
          # 3) Finalize: download chosen artifact and unzip
          if [ -n "$FOUND_DOWNLOAD_URL" ]; then
            echo "Selected run $FOUND_BUILD_ID (head_sha=$FOUND_RUN_HEAD_SHA). Downloading artifact ..."
            curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -o "${{ inputs.kernelsu_variant }}-Manager(${{ env.KSU_VERSION }}).zip" \
              "$FOUND_DOWNLOAD_URL"
            echo "Downloaded: ${{ inputs.kernelsu_variant }}-Manager(${{ env.KSU_VERSION }}).zip from run $FOUND_BUILD_ID"
            unzip -o "*.zip" || echo "unzip failed"
            rm -rf *.zip
          else
            echo "ERROR: Could not find Manager artifact matching criteria."
          fi
          
      - name: Adding the SUSFS module
        id: add_SUSFS
        continue-on-error: true
        run: |
          BUILD_ID=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/sidex15/susfs4ksu-module/actions/workflows/build.yml/runs?status=success" |
          jq -r '.workflow_runs[0].id')

          ARTIFACTS=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/sidex15/susfs4ksu-module/actions/runs/$BUILD_ID/artifacts")

          DOWNLOAD_URL=$(echo "$ARTIFACTS" | jq -r '.artifacts[0].archive_download_url') 

          NAME=$(echo "$ARTIFACTS" | jq -r '.artifacts[0].name')
          echo "SUSFS_NAME=$NAME" >> $GITHUB_ENV
          NAME="susfs-$NAME.zip"
          
          echo $DOWNLOAD_URL
          echo $NAME
          # Download the Manager file
          curl -L -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" -o "$NAME" "$DOWNLOAD_URL"
          echo "$NAME file downloaded.zip"
          
          
          echo "Checking caller: ${{ github.caller_workflow }}"

          # Called by the user or uploaded to the release by the author?

          if [ "${{ github.workflow }}" == "Test Release" ]; then
            echo "This is the test release workflow"
            mkdir -p susfs-module && mv $NAME susfs-module
          else
            echo "This is another workflow"
            mkdir -p susfs-module && unzip *.zip -d susfs-module
          fi

      - name: Notify on failure
        if: steps.add_KSU.outcome == 'failure'
        run: echo "Downloading CI built KSU failed!"

      - name: Upload APK
        if: steps.add_KSU.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.kernelsu_variant }}-Manager(${{ env.KSU_VERSION }})
          path: |
            *.apk

      - name: Upload the SUSFS module
        if: steps.add_SUSFS.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: susfs-${{ env.SUSFS_NAME }}
          path: ./susfs-module/*
