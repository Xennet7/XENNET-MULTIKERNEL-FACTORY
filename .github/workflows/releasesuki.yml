name: Release SUKISU

permissions:
  contents: write
  actions: write

on:
  workflow_call: # This allows this workflow to be called from another workflow
   inputs:
     kernelsu_variant:
       required: true
       type: string
     kernelsu_commit:
       required: false
       type: string
     susfs_commit:
       required: false
       type: string
       
  workflow_dispatch:
   inputs:
     kernelsu_variant:
       required: true
       type: string
     kernelsu_commit:
       required: false
       type: string
     susfs_commit:
       required: false
       type: string

jobs:

  release:
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}
      RELEASE_NAME: "GKI Kernels With XSUKI & SUSFS v2.0.0"
      RELEASE_BODY:
      
    steps:
    
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get KSU Versions
        run: |
          set -euo pipefail
          KERNELSU_VARIANT="${{ inputs.kernelsu_variant }}"
          KERNELSU_COMMIT="${{ inputs.kernelsu_commit }}"   # may be empty
          echo "Resolving KSU repo for variant: $KERNELSU_VARIANT (commit: ${KERNELSU_COMMIT:-none})"
          if [ "$KERNELSU_VARIANT" = "Next" ]; then
            echo "This is the Next variant"
            git clone https://github.com/KernelSU-Next/KernelSU-Next.git Verfold
          elif [ "$KERNELSU_VARIANT" = "SukiSU" ]; then
            echo "This is the SukiSU variant"
            git clone https://github.com/SukiSU-Ultra/SukiSU-Ultra.git Verfold
          elif [ "$KERNELSU_VARIANT" = "Official" ]; then
            echo "This is the Official variant"
            git clone https://github.com/tiann/KernelSU.git Verfold
          elif [ "$KERNELSU_VARIANT" = "MKSU" ]; then
            echo "This is the MKSU variant"
            git clone https://github.com/5ec1cff/KernelSU.git Verfold
          else
            echo "Unknown variant: $KERNELSU_VARIANT"
            exit 1
          fi
          cd Verfold
          if [ -n "$KERNELSU_COMMIT" ]; then
          echo "User requested KernelSU commit: $KERNELSU_COMMIT ‚Äî fetching and checking out"
          # Try to fetch the commit quickly (shallow), but if that makes history incomplete, unshallow.
          # 1) Try shallow fetch of the specific commit (fast)
          git fetch --depth=1 origin "$KERNELSU_COMMIT" || true
          # 2) If the repository is shallow or the commit has no ancestors locally, try to unshallow to get full history
          #    (this makes git rev-list --count return the repo-wide count).
          if git rev-parse --is-shallow-repository >/dev/null 2>&1 && [ "$(git rev-parse --is-shallow-repository 2>/dev/null)" = "true" ]; then
            echo "Repository is shallow ‚Äî attempting to unshallow to get full history..."
            git fetch --unshallow origin || {
              echo "unshallow failed, attempting deep fetch of all refs..."
              git fetch --depth=50000 origin || true
            }
          fi
          # Ensure the commit is present, try fetching it fully if needed
          git fetch origin "$KERNELSU_COMMIT" || git fetch --depth=1 origin "$KERNELSU_COMMIT" || true
          # Finally checkout the exact commit detached
          git checkout --detach "$KERNELSU_COMMIT"
          else
          echo "No specific commit requested ‚Äî using repo HEAD"
          fi
          # Calculating the KSU version number based on commit count
          KSU_GIT_VERSION=$(git rev-list --count HEAD)
          VAR=$([[ "$KERNELSU_VARIANT" == "SukiSU" ]] && echo 700 || echo 200)
          KSU_VERSION=$((10000 + KSU_GIT_VERSION + VAR))
          if [ "$KERNELSU_VARIANT" = "SukiSU" ]; then
            KSU_VERSION=$((40000 + KSU_GIT_VERSION - 2815))
          elif [ "$KERNELSU_VARIANT" = "Official" ] || [ "$KERNELSU_VARIANT" = "MKSU" ]; then
            KSU_VERSION=$((30000 + KSU_GIT_VERSION))
          fi
          echo "Determined KSU numeric version: $KSU_VERSION (commit: $(git rev-parse --short HEAD))"
          echo $KSU_VERSION
          echo "KSUVER=$KSU_VERSION" >> $GITHUB_ENV
          # cleanup
          echo "Deleting the directory"
          cd ..
          rm -rf Verfold  

      - name: Get commit hashes and generate commit URLs
        run: |
          GITLAB_OWNER="simonpunk"
          GITLAB_REPO="susfs4ksu"
          # User-provided commit (may be empty)
          SUSFS_COMMIT="${{ inputs.susfs_commit }}"
          declare -A BRANCH_MAP=(
            ["gki_android15_6_6"]="gki-android15-6.6"
          )
          for var_name in "${!BRANCH_MAP[@]}"; do
            branch_name="${BRANCH_MAP[$var_name]}"
            if [ -n "$SUSFS_COMMIT" ]; then
              echo "Using user-provided SUSFS commit: $SUSFS_COMMIT"
              COMMIT_HASH="$SUSFS_COMMIT"
            else
              echo "No SUSFS commit provided ‚Äî fetching branch HEAD"
              COMMIT_HASH=$(git ls-remote "https://gitlab.com/$GITLAB_OWNER/$GITLAB_REPO.git" "refs/heads/$branch_name" | awk '{ print $1 }')
            fi
            COMMIT_URL="https://gitlab.com/$GITLAB_OWNER/$GITLAB_REPO/-/commit/$COMMIT_HASH"
            echo "$branch_name Commit: $COMMIT_HASH"
            echo "$branch_name Commit URL: $COMMIT_URL"
            echo "COMMIT_HASH_${var_name}=$COMMIT_HASH" >> "$GITHUB_ENV"
            echo "COMMIT_URL_${var_name}=$COMMIT_URL" >> "$GITHUB_ENV"
          done
            
      - name: Get KernelSU variant refs and links
        run: |
          KERNELSU_COMMIT="${{ inputs.kernelsu_commit }}"
          if [ -n "$KERNELSU_COMMIT" ]; then
            echo "Using user-provided KernelSU commit: $KERNELSU_COMMIT"
            WKSU_REF="$KERNELSU_COMMIT"
          else
            echo "No KernelSU commit provided ‚Äî fetching latest main branch commit"
            WKSU_REF=$(git ls-remote "https://github.com/tiann/KernelSU.git" refs/heads/main | awk '{print $1}')
          fi
          WKSU_URL="https://github.com/tiann/KernelSU/commit/$WKSU_REF"
          echo "WKSU_REF=$WKSU_REF" >> $GITHUB_ENV
          echo "WKSU_URL=$WKSU_URL" >> $GITHUB_ENV
          echo "KernelSU Reference: $WKSU_REF"
          echo "KernelSU URL: $WKSU_URL"
          
          # Get Baseband-guard latest commit from main branch
          BBG_REF=$(git ls-remote "https://github.com/vc-teahouse/Baseband-guard.git" refs/heads/main | awk '{print $1}')
          BBG_URL="https://github.com/vc-teahouse/Baseband-guard/commit/$BBG_REF"
          echo "BBG_REF=$BBG_REF" >> $GITHUB_ENV
          echo "BBG_URL=$BBG_URL" >> $GITHUB_ENV

      
      - name: Generate and Create New Tag
        env:
            GH_TOKEN: ${{ github.token }}
        run: |
            LATEST_TAG=$(gh api repos/${{ github.repository }}/tags --jq '.[0].name')
            if [ -z "$LATEST_TAG" ]; then
              LATEST_TAG="v1.5.12-r0"
            fi
            
            NEW_TAG=$(echo "$LATEST_TAG" | awk -F'-r' '{suffix=$2; if (!suffix) suffix=0; suffix++; printf "%s-r%d", $1, suffix}')
    
            echo "New tag: $NEW_TAG"
            echo "NEW_TAG=${NEW_TAG}" >> $GITHUB_ENV

            git tag $NEW_TAG
            git push origin $NEW_TAG
            
     
      - name: Download Artifacts
        uses: actions/download-artifact@v5
        with:
          path: ./downloaded-artifacts
          pattern: 'XSUKI-*-AnyKernel3'

      - name: List downloaded artifacts
        run: |
          echo "Contents of downloaded-artifacts:"
          ls -R downloaded-artifacts || echo "Folder empty"
      
      - name: Extract selected artifacts cleanly
        run: |
          echo "üîç Selecting and extracting matching artifacts..."
          mkdir -p temp temp_extract
          # Step 1: Move only matching zips to temp/
          MATCH_ZIP_PATTERNS=("*XSUKI-*-AnyKernel3")
          for pattern in "${MATCH_ZIP_PATTERNS[@]}"; do
          find downloaded-artifacts -maxdepth 2 -type f -name "$pattern" -exec mv -f {} temp/ \;
          done
          echo "‚úÖ Selected zips moved to temp/:"
          ls -lh temp/ || echo "No matching zips found!"
          # Step 2: Extract zips from temp/ to temp_extract/
          for zipfile in temp/*.zip; do
          [ -e "$zipfile" ] || continue
          echo "üì¶ Extracting: $zipfile"
          unzip -q "$zipfile" -d temp_extract/
          done
          # Step 3: Move extracted files (not just zips) back to downloaded-artifacts/
          MATCH_FILE_PATTERNS=("*-XSUKI-*-AnyKernel3")
          for pattern in "${MATCH_FILE_PATTERNS[@]}"; do
          find temp_extract -type f -name "$pattern" -exec mv -f {} downloaded-artifacts/ \;
          done
          # Step 4: Clean up
          echo "üßπ Cleaning temporary folders..."
          rm -rf temp temp_extract
          echo "‚úÖ Final files in downloaded-artifacts/:"
          ls -lh downloaded-artifacts/ || echo "No extracted files found."
     
      - name: Set release body
        run: |
          cat << EOF > release_body.md
      
          **‚ú® XENNET SukiSU Ultra**
          **üåÄ XSUKI v${{ env.KSUVER }} v3.2.0-1ea6af52@susfs-main**
          **üõ°Ô∏è SUSFS ‡∂û v2.0.0**
          **‚öôÔ∏è KPM DISABLED. If needed patch it with SUKISU manger before flashing the kernel**
          **üåê IPSet Support for Advanced Network Filtering**
          **üü¢ WireGuard Support**
          **üöÄ BBR v1 Support**
          **üîí BBG Protection to Prevent Unauthorized Writes to Certain Partitions**
        
          Commit Hashes (at the time of release):
          -> XENNET SukiSU Ultra: [${{ env.WKSU_REF }}](${{ env.WKSU_URL }})

          -> Baseband-guard: [${{ env.BBG_REF }}](${{ env.BBG_URL }})
          
          -> SUSFS4KSU:
            -> gki-android15-6.6: [${{ env.COMMIT_HASH_gki_android15_6_6 }}](${{ env.COMMIT_URL_gki_android15_6_6 }})
          EOF

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.NEW_TAG }}
          prerelease: false
          files: ""
          name: ${{ env.RELEASE_NAME }}
          body_path: release_body.md

      - name: Upload Release Assets
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          for file in ./downloaded-artifacts/*/*; do
            if [ -d "$file" ]; then
              continue
            fi
            echo "Uploading $file..."
            gh release upload ${{ env.NEW_TAG }} "$file"
          done

          
      - name: Display Files Uploaded
        run: |
          echo "GitHub release created with the following files:"
          ls ./downloaded-artifacts/**/*
            
    
